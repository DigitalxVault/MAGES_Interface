const fs = require('fs');
const path = require('path');

const SOUNDS_DIR = path.join(process.cwd(), 'public', 'sounds');
const OUTPUT_DIR = path.join(process.cwd(), 'src', 'generated');

function getAudioFiles(directory) {
  const fullPath = path.join(SOUNDS_DIR, directory);
  if (!fs.existsSync(fullPath)) {
    console.warn(`Directory not found: ${fullPath}`);
    return [];
  }

  return fs.readdirSync(fullPath)
    .filter(file => file.toLowerCase().endsWith('.mp3') && file !== '.gitkeep')
    .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
}

function generateManifest() {
  // Ensure output directory exists
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  const manifest = {
    effects: getAudioFiles('effects'),
    background: getAudioFiles('background'),
    generatedAt: new Date().toISOString(),
  };

  // Generate TypeScript file
  const tsContent = `// Auto-generated by scripts/generate-audio-manifest.js
// Do not edit manually - regenerate with: npm run prebuild

export interface AudioManifest {
  effects: string[];
  background: string[];
  generatedAt: string;
}

export const audioManifest: AudioManifest = {
  effects: ${JSON.stringify(manifest.effects, null, 4).replace(/\n/g, '\n  ')},
  background: ${JSON.stringify(manifest.background, null, 4).replace(/\n/g, '\n  ')},
  generatedAt: '${manifest.generatedAt}',
};
`;

  fs.writeFileSync(path.join(OUTPUT_DIR, 'audio-manifest.ts'), tsContent);

  console.log('Audio manifest generated successfully!');
  console.log(`  Effects: ${manifest.effects.length} files`);
  manifest.effects.forEach(f => console.log(`    - ${f}`));
  console.log(`  Background: ${manifest.background.length} files`);
  manifest.background.forEach(f => console.log(`    - ${f}`));
}

generateManifest();
